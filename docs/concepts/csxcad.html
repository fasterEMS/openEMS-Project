<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CSXCAD &mdash; openEMS 0.0.35 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Properties" href="properties.html" />
    <link rel="prev" title="Concepts" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> openEMS
          </a>
              <div class="version">
                0.0.35
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Install</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Concepts</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">CSXCAD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coordinate-systems">Coordinate Systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saving">Saving</a></li>
<li class="toctree-l3"><a class="reference internal" href="#import-export">Import &amp; Export</a></li>
<li class="toctree-l3"><a class="reference internal" href="#models-and-simulations-reuse">Models and Simulations Reuse</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#matlab-octave">Matlab/Octave</a></li>
<li class="toctree-l4"><a class="reference internal" href="#python">Python</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#modeling-via-a-gui">Modeling via a GUI?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="properties.html">Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="primitives.html">Primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="mesh.html">Mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="bc.html">Boundary Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ports.html">Ports</a></li>
<li class="toctree-l2"><a class="reference internal" href="excitations.html">Excitation Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="signals.html">Signal Waveforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="dump.html">Field Dump</a></li>
<li class="toctree-l2"><a class="reference internal" href="dispersive.html">Dispersive Materials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../python/openEMS/Tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/python.html">Python Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../octave/octave.html">Octave/Matlab Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../more.html">Learn More</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">openEMS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Concepts</a> &raquo;</li>
      <li>CSXCAD</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/concepts/csxcad.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="csxcad">
<h1>CSXCAD<a class="headerlink" href="#csxcad" title="Permalink to this headline"></a></h1>
<section id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline"></a></h2>
<p>An openEMS simulation always starts by creating a 3D model of the structure
using the CSXCAD library. All created entities for the simulation are stored
in the <code class="docutils literal notranslate"><span class="pre">csx</span></code> data structure (or Python object), which must be initialized
first. It’s done by either the <a class="reference internal" href="../octave/autogenerated/CSXCAD/InitCSX.html#InitCSX" title="InitCSX"><code class="xref py py-func docutils literal notranslate"><span class="pre">InitCSX()</span></code></a> method in Matlab/Octave, or
the <a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure" title="CSXCAD.ContinuousStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContinuousStructure</span></code></a> class in Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">Matlab</span><span class="o">/</span><span class="n">Octave</span>
<span class="n">csx</span> <span class="o">=</span> <span class="n">InitCSX</span><span class="p">();</span>

<span class="c1"># Python</span>
<span class="kn">import</span> <span class="nn">CSXCAD</span>
<span class="n">csx</span> <span class="o">=</span> <span class="n">CSXCAD</span><span class="o">.</span><span class="n">ContinuousStructure</span><span class="p">()</span>
</pre></div>
</div>
<p>Once initialized, 3D models can be created by the functions provided by CSXCAD.
In Matlab/Octave, nearly all of them accept an old instance of the <cite>csx</cite> data
structure, and returns a modified new one. The Python binding has a more modern
coding style in comparison, which achieves this via class methods rather than
functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">Matlab</span><span class="o">/</span><span class="n">Octave</span>
<span class="n">csx</span> <span class="o">=</span> <span class="n">AddExample</span><span class="p">(</span><span class="n">csx</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>

<span class="c1"># Python</span>
<span class="n">csx</span><span class="o">.</span><span class="n">AddExample</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>These CSXCAD functions can be classified into two types, <em>properties</em>
and <em>primitives</em>. They define material properties and shapes respectively.</p>
<p><em>Properties</em> defines the physical property of a material, such as a metal,
a thin conducting sheet, a dielectric metarial, a magnetic material.
Technically, excitation sources, probes, and field dump boxes are also
<em>Properties</em>.</p>
<p><em>Primitives</em> are the building blocks to create 1D, 2D, 3D shapes, so that one
can create simple object such as a Curve, a Polygon, a Box, or a Sphere. More
complex structures can be created by combining various primitives. For example,
a metal sheet with cylindrical holes can be achieved by combining a metal box
with several air cylinders.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See <a class="reference internal" href="properties.html#concept-properties"><span class="std std-ref">Properties</span></a> and <a class="reference internal" href="primitives.html#concept-primitives"><span class="std std-ref">Primitives</span></a> for details.</p>
</div>
</section>
<section id="coordinate-systems">
<h2>Coordinate Systems<a class="headerlink" href="#coordinate-systems" title="Permalink to this headline"></a></h2>
<p>By default, a Cartesian coordinate system is used, which is suitable for
most simulations. If the simulated structure is predominantly round, the
Cartesian mesh may have a difficult time aligning itself with an object’s
surfaces. Hence openEMS provides the alternative cylindrical coordinate
system to minimize staircasing errors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">Matlab</span><span class="o">/</span><span class="n">Octave</span>
<span class="n">csx</span> <span class="o">=</span> <span class="n">InitCSX</span><span class="p">(</span><span class="s1">&#39;CoordSystem&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">);</span>

<span class="c1"># Python</span>
<span class="kn">import</span> <span class="nn">CSXCAD</span>
<span class="n">csx</span> <span class="o">=</span> <span class="n">CSXCAD</span><span class="o">.</span><span class="n">ContinuousStructure</span><span class="p">(</span><span class="n">CoordSystem</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This mainly affects meshing of the simulation box during a simulation,
not the coordinates of 3D structures themselves. When creating 3D
models, their coordinates do follow the meshing coordinate system by
default, but it can always be overridden.</p>
</div>
</section>
<section id="saving">
<h2>Saving<a class="headerlink" href="#saving" title="Permalink to this headline"></a></h2>
<p>Once modeled, the CSXCAD data structure is usually saved to disk as an
<code class="docutils literal notranslate"><span class="pre">.xml</span></code> file. It can be inspected by the <strong class="program">AppCSXCAD</strong> 3D viewer
for debugging:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AppCSXCAD</span> <span class="n">simulation</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<figure class="align-default" id="id1">
<a class="with-border reference internal image-reference" href="../_images/appcsxcad.png"><img alt="../_images/appcsxcad.png" class="with-border" src="../_images/appcsxcad.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-text">AppCSXCAD, CSXCAD’s official 3D model viewer and editor.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>In the Matlab/Octave binding, both the geometry and simulation parameters
are saved together as a self-contained <code class="docutils literal notranslate"><span class="pre">.xml</span></code> file. The former is
created by <a class="reference internal" href="../octave/autogenerated/CSXCAD/InitCSX.html#InitCSX" title="InitCSX"><code class="xref py py-func docutils literal notranslate"><span class="pre">InitCSX()</span></code></a> and controlled by the <code class="docutils literal notranslate"><span class="pre">csxcad</span></code> data structure,
the latter is created by <a class="reference internal" href="../octave/autogenerated/openEMS/InitFDTD.html#InitFDTD" title="InitFDTD"><code class="xref py py-func docutils literal notranslate"><span class="pre">InitFDTD()</span></code></a> and controlled by the <code class="docutils literal notranslate"><span class="pre">fdtd</span></code> data
structure. Hence <code class="xref py py-func docutils literal notranslate"><span class="pre">WriteOpenEMS()</span></code> requires both inputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CSX</span> <span class="o">=</span> <span class="n">InitCSX</span><span class="p">();</span>
<span class="n">FDTD</span> <span class="o">=</span> <span class="n">InitFDTD</span><span class="p">();</span>

<span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;/tmp&#39;</span><span class="p">;</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;simulation.xml&#39;</span><span class="p">;</span>

<span class="o">%</span> <span class="n">write</span> <span class="n">openEMS</span> <span class="n">compatible</span> <span class="n">xml</span><span class="o">-</span><span class="n">file</span>
<span class="n">WriteOpenEMS</span><span class="p">([</span><span class="n">path</span> <span class="s1">&#39;/&#39;</span> <span class="n">filename</span><span class="p">],</span> <span class="n">fdtd</span><span class="p">,</span> <span class="n">csx</span><span class="p">);</span>
</pre></div>
</div>
<p>In the Python binding, only the CSXCAD geometry information is saved to
the <code class="docutils literal notranslate"><span class="pre">.xml</span></code> file using the <a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure.Write2XML" title="CSXCAD.ContinuousStructure.Write2XML"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Write2XML()</span></code></a>
method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pathlib</span>

<span class="n">simdir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="p">)</span>
<span class="n">xmlname</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;simulation.xml&quot;</span><span class="p">)</span>

<span class="c1"># concat two paths</span>
<span class="n">xmlpath</span> <span class="o">=</span> <span class="n">simdir</span> <span class="o">/</span> <span class="n">xmlname</span>

<span class="n">csx</span><span class="o">.</span><span class="n">Write2XML</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">xmlpath</span><span class="p">))</span>  <span class="c1"># convert Path object to string</span>
</pre></div>
</div>
</section>
<section id="import-export">
<h2>Import &amp; Export<a class="headerlink" href="#import-export" title="Permalink to this headline"></a></h2>
<p>Several Matlab/Octave functions are provided to import or export the
CSXCAD model to other formats, they include:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../octave/autogenerated/CSXCAD/ImportPLY.html#ImportPLY" title="ImportPLY"><code class="xref py py-func docutils literal notranslate"><span class="pre">ImportPLY()</span></code></a>, <a class="reference internal" href="../octave/autogenerated/CSXCAD/ImportSTL.html#ImportSTL" title="ImportSTL"><code class="xref py py-func docutils literal notranslate"><span class="pre">ImportSTL()</span></code></a>:</p>
<ul>
<li><p>Especially useful for importing a 3rd-party 3D model (such as a
connector).</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="../octave/autogenerated/CSXCAD/export_gerber.html#export_gerber" title="export_gerber"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_gerber()</span></code></a>, <a class="reference internal" href="../octave/autogenerated/CSXCAD/export_excellon.html#export_excellon" title="export_excellon"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_excellon()</span></code></a>:</p>
<ul>
<li><p>CAM file outputs for fabrication. Useful for automated generation of
planar circuits.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="../octave/autogenerated/CSXCAD/export_empire.html#export_empire" title="export_empire"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_empire()</span></code></a>:</p>
<ul>
<li><p>For comparing simulation results with proprietary, commercial
tools.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="../octave/autogenerated/CSXCAD/export_povray.html#export_povray" title="export_povray"><code class="xref py py-func docutils literal notranslate"><span class="pre">export_povray()</span></code></a>:</p>
<ul>
<li><p>For rendering fancy ray-traced 3D images.</p></li>
</ul>
</li>
</ul>
<figure class="align-default" id="id2">
<a class="with-border reference internal image-reference" href="../_images/povray-2.4ghz-planar.png"><img alt="../_images/povray-2.4ghz-planar.png" class="with-border" src="../_images/povray-2.4ghz-planar.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-text">Rendering of a 2.4 GHz planar circuit by raytracing.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Python.</strong> These functions are not implemented in Python yet. As
a workaround, for importing, one can use Matlab/Octave to import an
STL model (<a class="reference internal" href="../octave/autogenerated/CSXCAD/ImportSTL.html#ImportSTL" title="ImportSTL"><code class="xref py py-func docutils literal notranslate"><span class="pre">ImportSTL()</span></code></a>), export the result to <code class="docutils literal notranslate"><span class="pre">.xml</span></code>, and
load the
model in Python via <a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure.ReadFromXML" title="CSXCAD.ContinuousStructure.ReadFromXML"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ReadFromXML()</span></code></a>.
For exporting, <strong class="program">AppCSXCAD</strong> itself can generate POV-Ray,
STL, X3D, Polydata-VTK, and PNG file formats.</p>
<p><strong>Importing is easy, meshing is hard.</strong>
Importing an external model is considered an advanced feature, beginners
are <em>not recommended</em> to try them before familiarizing themselves with the
CSXCAD/openEMS workflow first via basic simulations, as described in
<a class="reference internal" href="../python/openEMS/Tutorials/First_Lessons.html#first-lessons"><span class="std std-ref">First Lessons For Circuit Designers</span></a>. Creating a
meshing-friendly model (see <a class="reference internal" href="mesh.html#concept-mesh"><span class="std std-ref">Mesh</span></a>) is often difficult,
so a model and a mesh is usually co-developed. If a model comes from
another source, yet the user is not already familiar with the meshing
process and its pitfalls, confusing problems may arise.</p>
</div>
</section>
<section id="models-and-simulations-reuse">
<h2>Models and Simulations Reuse<a class="headerlink" href="#models-and-simulations-reuse" title="Permalink to this headline"></a></h2>
<p>The development of the Matlab/Octave and Python bindings took different
paths, as a result, they behave differently in terms of reusing models
and simulations.</p>
<section id="matlab-octave">
<h3>Matlab/Octave<a class="headerlink" href="#matlab-octave" title="Permalink to this headline"></a></h3>
<p>The Matlab/Octave binding was written as a pure “XML generator frontend”
to CSXCAD, and the openEMS executable was used as an “executable backend”.
All Matlab/Octave operations (such as geometries and simulation
settings) are only wrapper to the underlying <code class="docutils literal notranslate"><span class="pre">.xml</span></code> file writer. Once
generated, openEMS is launched and took over the simulation independently.
As a result, the same <code class="docutils literal notranslate"><span class="pre">.xml</span></code> file can be directly used to replay the same
simulation via the <code class="docutils literal notranslate"><span class="pre">openEMS</span></code> command-line in the future, even without the
source code. For example, it can be useful for constructing a simulation on
the local machine, but running simulation on a headless server:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">openEMS</span> <span class="n">simulation</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<p>However, since the Matlab/Octave binding is only an <code class="docutils literal notranslate"><span class="pre">.xml</span></code> generator without
direct access to CSXCAD itself, the generated <code class="docutils literal notranslate"><span class="pre">.xml</span></code> file is “a one-way street”
that can’t be reloaded as a Matlab/Octave data structure after the fact.
Source code must be kept if the generated structure or simulation needs any
future modifications. Overall, the Matlab/Octave binding works like a static
website generator. One can generate web pages, but can’t edit the HTML files
back into the source format.</p>
</section>
<section id="python">
<h3>Python<a class="headerlink" href="#python" title="Permalink to this headline"></a></h3>
<p>In the Python binding, a decision was made to create a library-level binding to
both CSXCAD and openEMS. When geometries are created, rather than generating the
matching <code class="docutils literal notranslate"><span class="pre">.xml</span></code> code, it uses the actual funcions and internal data structure
within the CSXCAD library. As a result, it’s possible to reload an existing
CSXCAD 3D <code class="docutils literal notranslate"><span class="pre">.xml</span></code> model via <a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure.ReadFromXML" title="CSXCAD.ContinuousStructure.ReadFromXML"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ReadFromXML()</span></code></a>.</p>
<p>However, because the simulation is started by invoking openEMS as a library
directly rather than passing simulation parameters via <code class="docutils literal notranslate"><span class="pre">.xml</span></code> file, no
simulation parameters are written to the file. Hence the file is not standalone
and insufficient to start the simulation. Running the simulation requires a
functional Python script with both an instance of
<a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure" title="CSXCAD.ContinuousStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContinuousStructure</span></code></a> and an instance of <a class="reference internal" href="../python/openEMS/openEMS.html#openEMS.openEMS" title="openEMS.openEMS"><code class="xref py py-class docutils literal notranslate"><span class="pre">openEMS</span></code></a>.</p>
<p>However, a sourceless simulation replay is partially possible, by reusing
an earlier CSXCAD 3D <code class="docutils literal notranslate"><span class="pre">.xml</span></code> model via <a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure.ReadFromXML" title="CSXCAD.ContinuousStructure.ReadFromXML"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ReadFromXML()</span></code></a>
and setting up the rest.
If there’s a need, in principle one can write a self-written lightweight wrapper
for this purpose (no built-in implementations exist currently)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Replaying Simulations</strong>. Sometimes it may be desirable to “replay” an
existing simulation setup without access to the Matlab/Octave or Python
source code. This is possible in Matlab/Octave, but only partially
possible in Python.</p>
<p><strong>Post-Processing</strong>. In all cases, post-processing simulation results
always requires source code. The program <code class="docutils literal notranslate"><span class="pre">openEMS</span></code> itself is only a
field solver engine. For analysis, we rely on Matlab/Octave or Python
routines.</p>
<p><strong>Third-Party Apps</strong>.  If you’re developing a third-party simulator
or binding based on openEMS, it’s recommended to generate a simulation
<code class="docutils literal notranslate"><span class="pre">.xml</span></code> and to call openEMS as an executable. The openEMS is a shared
library, but it’s so far not designed for public use. On the other
hand, the CSXCAD library is designed to be publicly reusable, so it’s
acceptable to either generate the <code class="docutils literal notranslate"><span class="pre">.xml</span></code> yourself or invoke the CSXCAD
library to do that, as a result, the recommendation is a hybrid of
the approaches used by Matlab/Octave and Python bindings.</p>
</div>
</section>
</section>
<section id="modeling-via-a-gui">
<h2>Modeling via a GUI?<a class="headerlink" href="#modeling-via-a-gui" title="Permalink to this headline"></a></h2>
<p>In principle, it’s feasible to make or tweak a 3D model using the
<strong class="program">AppCSXCAD</strong> GUI. Geometries and mesh lines can be added
by the GUI (or an initial program), a modified version can be saved
and read into Python later for simulation via
<a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure.ReadFromXML" title="CSXCAD.ContinuousStructure.ReadFromXML"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ReadFromXML()</span></code></a>.
This method circumvents programmatic modeling
(as decribed in <a class="reference internal" href="primitives.html#concept-primitives"><span class="std std-ref">Primitives</span></a>) entirely - although it
has not been put in use by anyone to our best knowledge.</p>
<p>On the other hand, there are numerious attempts over the years
to create models using GUI-based or high-level tools, to varying
degrees of success.</p>
<p>The first general idea is to create the structure first in a
general-purpose CAD like FreeCAD. This can then be exported as
a 3D model and be loaded into CSXCAD via <a class="reference internal" href="../octave/autogenerated/CSXCAD/ImportSTL.html#ImportSTL" title="ImportSTL"><code class="xref py py-func docutils literal notranslate"><span class="pre">ImportSTL()</span></code></a> for
simulation. By editing the CSXCAD object further, ports and
probes can also be modeled as a GUI.</p>
<p>The second general idea, specific to planar circuits and circuit
board simulations, is to first create the circuit board using an
EDA tool such as gEDA, pcb-rnd, or KiCad. The circuit layout
can then be exported as a 2D vector image format, such as
HyperLynx, Gerber, SVG or PDF. The polygons in these images
are then extracted and imported as CSXCAD polygons.</p>
<p>The third general idea, is to create a high-level programming
library for defining high-level objects such as traces, vias,
circuit board layers, so that they can be created one object
at a them, rather than one polygon at a time.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><strong>Third-Party Tools.</strong> These tools are developed by third
parties, and not officially supported by the openEMS project.
Most of them are highly experimental and incomplete.
They’re described here for completeness. The project forum
is also open to the discussions of their uses.</p>
<p><strong>Importing is easy, simulation is hard.</strong> These tools
should be considered advanced applications. Beginners are
<em>not recommended</em> to try them before familiarizing themselves
with the CSXCAD/openEMS workflow first via basic simulations,
as described in <a class="reference internal" href="../python/openEMS/Tutorials/First_Lessons.html#first-lessons"><span class="std std-ref">First Lessons For Circuit Designers</span></a>.
Trying to import a circuit board without understanding the
concept of ports, boundary conditions or meshing rules leads
to failures, especially when most of these tools are highly
experimental and incomplete.</p>
<p><strong>Don’t work in isolation.</strong> By far there are already 7 different
tools that attempt to automate modeling of circuit boards and
3D objects for openEMS. Instead of creating another one from
scratch, it’s probably a good idea to have a discussion with
the authors of these existing tools.</p>
</div>
<p>Examples of these tools include:</p>
<ul class="simple">
<li><p><strong class="program">FreeCAD-OpenEMS-Export</strong>, developed by Lubomir Jagos.</p>
<ul>
<li><p>FreeCAD-based model and port edits, with CSXCAD export.</p></li>
<li><p><a class="reference external" href="https://github.com/LubomirJagos/FreeCAD-OpenEMS-Export">https://github.com/LubomirJagos/FreeCAD-OpenEMS-Export</a></p></li>
</ul>
</li>
<li><p><strong class="program">IntuitionRF</strong>, developed by Juleinn.</p>
<ul>
<li><p>It allows one to mesh structures interactively via Blender.</p></li>
<li><p><a class="reference external" href="https://github.com/Juleinn/IntuitionRF">https://github.com/Juleinn/IntuitionRF</a></p></li>
</ul>
</li>
<li><p><strong class="program">pcb2csx</strong>, developed by Evan Foss.</p>
<ul>
<li><p>It’s a plugin to the EDA tool <strong class="program">pcb-rnd</strong>,
allowing one to export an existing circuit board layout to CSXCAD.</p></li>
<li><p><a class="reference external" href="http://repo.hu/cgi-bin/pool.cgi?project=pcb-rnd&amp;cmd=show&amp;node=s_param">http://repo.hu/cgi-bin/pool.cgi?project=pcb-rnd&amp;cmd=show&amp;node=s_param</a></p></li>
</ul>
</li>
<li><p><strong class="program">gerber2ems</strong>, developed by Antmicro.</p>
<ul>
<li><p>It allows one to export an existing PCB layout as a Gerber file,
which can then be converted and imported as a CSXCAD model.</p></li>
<li><p><a class="reference external" href="https://github.com/antmicro/gerber2ems">https://github.com/antmicro/gerber2ems</a></p></li>
</ul>
</li>
<li><p><strong class="program">pcbmodelgen</strong>, developed by jcyrax.</p>
<ul>
<li><p>It converts a KiCad layout file into the CSXCAD model,
also with experimental auto-meshing support.</p></li>
<li><p><a class="reference external" href="https://github.com/jcyrax/pcbmodelgen">https://github.com/jcyrax/pcbmodelgen</a></p></li>
</ul>
</li>
<li><p><strong class="program">pyems</strong>, developed by Matt Huszagh.</p>
<ul>
<li><p>It’s a high-level Python interface to openEMS, which allows
the programmatic creation of high-level structures such as
circuit boards, traces, vias, PCB layers. It has also an
experimental auto-mesh generation algorithm.</p></li>
<li><p><a class="reference external" href="https://github.com/matthuszagh/pyems">https://github.com/matthuszagh/pyems</a></p></li>
</ul>
</li>
<li><p><strong class="program">hyp2mat</strong>, developed by Koen De Vleeschauwer and
distributed officially as part of openEMS.</p>
<ul>
<li><p>It converts a
HyperLynx layout file (can be generated by PCB EDA tools,
including EAGLE or KiCad 6). The geometries are extracted
to generate an Octave script with commands to create
the CSXCAD model.</p></li>
<li><p>In principle, it can be used with Python
as well, by exporting the model to XML in Octave via
<code class="xref py py-func docutils literal notranslate"><span class="pre">WriteOpenEMS()</span></code>, and importing the model via
<a class="reference internal" href="../python/CSXCAD/CSXCAD.html#CSXCAD.ContinuousStructure.ReadFromXML" title="CSXCAD.ContinuousStructure.ReadFromXML"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ReadFromXML()</span></code></a>. But
no one has tested it.</p></li>
<li><p>Currently it’s retired and no longer maintained.</p></li>
<li><p><a class="reference external" href="https://github.com/koendv/hyp2mat">https://github.com/koendv/hyp2mat</a></p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The old project wiki also described this following idea to
convert circuit board layouts from Gerber, PDF, DXF, or
G into CSXCAD models. This idea may be of interest to
developers working on automated CSXCAD model generation.</p>
<p>PCB layers in Gerber files can be converted to PDF by means of
gerber2pdf which can be found on Sourceforge (editor’s note:
native PDF, SVG and DXF exports are available in many EDA packages).
The PDF can be imported into Inkscape just as it is the case
for DXF files. Within Inkscape, the usually closed paths can be
modified (either manually or with filters) such that they result
in a suitable list of polygon nodes for openEMS.</p>
<p>Sometimes these polygons or curves have too many nodes. The number
of nodes can be reduced with the Inkscape function “Path” &gt; “Simplify”.
The amount of reduction is controlled by the parameter “Simplification
Threshold” which can be found under “Preferences” &gt; “Behavior”. These
paths are still Bézier curves which must be converted into polygons.
This is achieved with “Extensions” &gt; “Modify Path” &gt; “Flatten Béziers”.
The parameter in this dialog also controls the number of resulting
points.</p>
<p>When all nodes are as required, the paths can be exported as a HTML5
Canvas. The resulting file can then be processed with an ASCII Editor.
The numbers after the moveTo and lineTo statements are the polygon nodes
X- and Y- coordinates respectively. However, they still must be
transformed ba a liner transform given in the transform statement. The
first four numbers a matrix by which the node coordinates have to be
multiplied and the remaining two numbers are a vector which has to
be added.</p>
<p>The result will be the node coordinates in HTML pixels with X counting
from left to right and Y counting from top to bottom, which does not
conform to the coordinate system of the Inkscape canvas.</p>
<p>In order to have the same axes as in Inkscape (X left to right and Y
bottom to top), the fourth an sixth number have to be multiplied by -1
and the image height has to be added to the sixth number. Now the
coordinates are in the usual coordinate system but still in HTML5 pixels.
The ratio of pixels to mm or other units of length can finally be found
under the document properties in Inkscape. This factor can be applied in
Octave/Matlab. This finally gives polygons which can be processed by openEMS.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Concepts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="properties.html" class="btn btn-neutral float-right" title="Properties" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Thorsten Liebig.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>